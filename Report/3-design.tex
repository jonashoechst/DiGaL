%!TEX root = report.tex

\chapter{Designentscheidungen}
\label{cha:designentscheidungen}

\section{Qualitäten der Sprache} % (fold)
\label{sec:qualitaten_der_sprache}


\subsection{Modularität} % (fold)
\label{sub:modularitat}
\subsubsection{Funktionsdefinitionen}
\label{subsub:funktionsdefinitionen}
	DiGaL bietet keine Konzepte, um Modular Spiele entwickeln zu können. Diese Entscheidung ist bewusst so gewählt worden. Auch hier stand wieder der Fokus im Vordergrund, die Sprache so einfach wie möglich zu gestalten. Ein Programm in Module aufzuteilen heißt zum Beispiel eine Möglichkeit zu bieten Funktionen oder Methoden zu definieren, in denen Aktionen gekapselt sind, die wiederholt ausgeführt werden können. Dies würde aber bedeuten, dass man ein Konzept benötigt, dass einem einen solchen Mechanismus erlaubt. Und dieses neue Konzept müsste von Anwendern unserer Sprache erlernt werden, wenn sie keine Programmierer sind. Daher haben wir uns dazu entschieden, keine Möglichkeit anzubieten Funktionen zu definieren. Es schien uns einfacher dem Nutzer die Möglichkeit zu geben, Aktionen wiederholt zu definieren.

	Desweiteren besteht ein Würfelspiel in DiGaL aus vier Blöcken, wie sie in \todo{REF EINFÜGEN} vorgestellt werden. Die Möglichkeit Funktionen zu definieren würde daher bedeuten, dass dieses strikte Konzept gebrochen werden müsste, was wiederum ein Mehr an Komplexität bedeuten würde.
\subsubsection{Auslagern in andere Dateien}
\label{subsub:auslagern_in_andere_dateien}
	Da Spiele, die in DiGaL geschrieben sind, nur aus vier Blöcken bestehen, schien es uns nicht sinnvoll, eine Art der Auslagerung von Code in andere Dateien einzuführen. Auch hier müsste mit dem Konzept der strikten Blockbildung gebrochen werden und eine Möglichkeit geschaffen werden diese Dateien einzubinden oder zu importieren. Das könnte unerfahrene Nutzer jedoch zusätzlich verwirren, da es aus unserer Sicht nicht mit unserem Konzept vereinbar ist, DiGaL eine kontrollierte Sprache zu Grunde zu legen, da es kein sprachliches Konzept gibt, dass paradigmatisch das gleiche aussagt.
\subsubsection{Erweiterung bestehender Spiele}
\label{subsub:erweiterung_bestehender_spiele}
	Eine weitere Möglichkeit der Modularisierung ist bestehende Spiele, also in unserem Fall bestehenden Code zu erweitern. Die aktuell DiGaL Version bietet dieses Konstrukt nicht an. Denkbar wäre aber eine Art Vererbung, in dem ein Spiel auf einem anderen Basiert und jeder Block um weitere Anweisungen ergänzt werden kann (hinzufügen von Würfeln, zusätzliche Aktionen bei bestimmten Ergebnissen, ...). Diese Vererbung sollte ein Spiel jedoch nur erweitern, nicht aber bestehende Regeln außer Kraft setzen können, da dies zum einen wieder zu Lasten der Verständlichkeit geschehen würde. Zum andern würde eine Änderung des zugrundeliegenden Spieles faktisch einer Neuentwicklung gleich kommen und sollte aus diesem Grund auch so behandelt werden.

% subsection modularitat (end)

\subsection{Robustheit} % (fold)
\label{sub:robustheit}
Alle DiGaL Programme haben einen festen Rahmen, dessen freie Flächen durch Variablendefinitionen, Arithmetische Operationen und Kontrollflussanweisungen gefüllt werden. Im Gegensatz zu klassischen Programmiersprachen ist der Programmierer dadurch in seiner Mächtigkeit sehr eingeschränkt. Durch diese Einschränkung ist es ihm wiederum auch weniger leicht möglich, Fehler zu produzieren. Treten Programmierfehler im DiGaL Programm auf, sind diese schon durch die Syntax invalidiert und können nicht in ein Programm übersetzt werden. Als Beispiel sei hier die Iteration über eine Variable genannt, die in unserer Sprache nur als Iteration über eine Gruppe von Spielern oder Würfeln vorgesehen ist. 

Funktions- oder Klassendefinitionen sind in DiGaL nicht vorgesehen, der rein Iterative Ansatz reicht aus unserer Sicht aus, den Kontrollfluss und die Komplexität von Würfelspielen zu beschreiben.

Würfelspiele sind in ihren möglichen Ausgängen begrenzt und dadurch gut testbar. Eine kleine Zahl an Würfeln mit einer geringen Zahl an Würfelflächen, die in einer festen Kontrollstruktur verwendet werden, macht es möglich alle Fälle des Programmes dazu generieren und die Spielausgänge zu testen.
% subsection robustheit (end)

\subsection{Datenmodellierung} % (fold)
\label{sub:datenmodellierung}
DiGaL bietet keine Möglichkeit um Datenobjekte oder -strukturen anzulegen. Wie unterstützen einen allerdings einen Aspekt der Objektorientiertheit, in dem wir die Möglichkeit bieten, einem Spieler Variablen zuzuordnen. Die einzigen erweiterteren Objekte sind also die Spieler. Alle vom Nutzer definierten Variablen, die nicht zu Spielern gehören lassen sich nur im global als Variable des Spiels anlegen.

Als weiteres (nicht modifizierbares) Objekt sind Würfel zu nennen, deren Namen und Seiten zwar vom Programmierer definiert, nicht aber neue Felder hinzugefügt werden können.
% subsection datenmodellierung (end)

\subsection{Abstraktionsniveau} % (fold)
\label{sub:abstraktionsniveau}
	Das Abstraktionsniveau in \dg ist bewusst sehr hoch gewählt. Auch hier stand wieder die Einfachheit der Sprache im Vordergrund. Daher haben wir keinerlei Möglichkeiten geschaffen beispielsweise auf Adressen im Arbeitsspeicher zuzugreifen oder Operationen auf Bits oder Bytes auszuführen. Auch typische Probleme in anderen Programmiersprachen wie Initialisierung oder Speicherverwaltung werden vom Compiler übernommen, sodass sich vor Allem unerfahrene Nutzer nicht um derlei Probleme kümmern müssen. 
% subsection abstraktionsniveau (end)

\subsection{Verständlichkeit} % (fold)
\label{sub:verstandlichkeit}
	Die Verständlichkeit von \dg ist gegeben durch die Verwendung der kontrollierten Sprache. Dadurch ergeben sich keine syntaktisch kryptischen Konstruktionen, die bei späterem Betrachten aufwendig rekonstruiert werden müssen. Auch die Unterstützung von alternativen Formulierungen (siehe \todo{REF}) vereinfacht die Verständlichkeit. Falls sich doch komplexe Ausdrücke ergeben sollten, die nicht auf Anhieb verständlich sind, haben wir die Möglichkeit geschaffen den Code durch Kommentare zu erklären.

% subsection verstandlichkeit (end)

% section qualitaten_der_sprache (end)

\section{Alternativen im Sprachdesign} % (fold)
\label{sec:alternativen_im_sprachdesign}

% section alternativen_im_sprachdesign (end)

\section{Domänenbezug} % (fold)
\label{sec:domanenbezug}

% section domanenbezug (end)